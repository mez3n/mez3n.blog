<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pthread Internals: How Condition Variables Work | Mez3n&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Understanding Pthread Condition Variables from the Inside
In this blog post, we&rsquo;ll explore how pthread synchronization primitives work internally, focusing on condition variables. We&rsquo;ll dive deep into the RTEMS implementation to understand how pthread_cond_wait, pthread_cond_timedwait, and pthread_cond_clockwait work under the hood.
Why Start with pthread_cond_clockwait?
We&rsquo;ll begin with pthread_cond_clockwait because it&rsquo;s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.">
<meta name="author" content="">
<link rel="canonical" href="https://mez3n.github.io/mez3n.blog/posts/pthreadinternals/">
<link crossorigin="anonymous" href="/mez3n.blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mez3n.github.io/mez3n.blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mez3n.github.io/mez3n.blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mez3n.github.io/mez3n.blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mez3n.github.io/mez3n.blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://mez3n.github.io/mez3n.blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://mez3n.github.io/mez3n.blog/posts/pthreadinternals/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://mez3n.github.io/mez3n.blog/posts/pthreadinternals/">
  <meta property="og:site_name" content="Mez3n&#39;s Blog">
  <meta property="og:title" content="Pthread Internals: How Condition Variables Work">
  <meta property="og:description" content="Understanding Pthread Condition Variables from the Inside In this blog post, we’ll explore how pthread synchronization primitives work internally, focusing on condition variables. We’ll dive deep into the RTEMS implementation to understand how pthread_cond_wait, pthread_cond_timedwait, and pthread_cond_clockwait work under the hood.
Why Start with pthread_cond_clockwait? We’ll begin with pthread_cond_clockwait because it’s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-06T01:10:41+03:00">
    <meta property="article:modified_time" content="2025-07-06T01:10:41+03:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pthread Internals: How Condition Variables Work">
<meta name="twitter:description" content="Understanding Pthread Condition Variables from the Inside
In this blog post, we&rsquo;ll explore how pthread synchronization primitives work internally, focusing on condition variables. We&rsquo;ll dive deep into the RTEMS implementation to understand how pthread_cond_wait, pthread_cond_timedwait, and pthread_cond_clockwait work under the hood.
Why Start with pthread_cond_clockwait?
We&rsquo;ll begin with pthread_cond_clockwait because it&rsquo;s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mez3n.github.io/mez3n.blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Pthread Internals: How Condition Variables Work",
      "item": "https://mez3n.github.io/mez3n.blog/posts/pthreadinternals/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pthread Internals: How Condition Variables Work",
  "name": "Pthread Internals: How Condition Variables Work",
  "description": "Understanding Pthread Condition Variables from the Inside In this blog post, we\u0026rsquo;ll explore how pthread synchronization primitives work internally, focusing on condition variables. We\u0026rsquo;ll dive deep into the RTEMS implementation to understand how pthread_cond_wait, pthread_cond_timedwait, and pthread_cond_clockwait work under the hood.\nWhy Start with pthread_cond_clockwait? We\u0026rsquo;ll begin with pthread_cond_clockwait because it\u0026rsquo;s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.\n",
  "keywords": [
    
  ],
  "articleBody": "Understanding Pthread Condition Variables from the Inside In this blog post, we’ll explore how pthread synchronization primitives work internally, focusing on condition variables. We’ll dive deep into the RTEMS implementation to understand how pthread_cond_wait, pthread_cond_timedwait, and pthread_cond_clockwait work under the hood.\nWhy Start with pthread_cond_clockwait? We’ll begin with pthread_cond_clockwait because it’s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.\nThe Entry Point: condclockwait.c Let’s start by examining the implementation of pthread_cond_clockwait in condclockwait.c:\nint pthread_cond_clockwait( pthread_cond_t *cond, pthread_mutex_t *mutex, clockid_t clock_id, const struct timespec *abstime ) { if ( abstime == NULL ) { return EINVAL; } if ( clock_id != CLOCK_MONOTONIC \u0026\u0026 clock_id != CLOCK_REALTIME ) { return EINVAL; } return _POSIX_Condition_variables_Wait_support( cond, mutex, abstime, \u0026clock_id ); } Parameter Validation The function performs critical validation checks as required by the POSIX specification:\nTimeout validation: abstime cannot be NULL for a timed wait Clock validation: Only CLOCK_MONOTONIC and CLOCK_REALTIME are supported Notice that clock_id is passed as a reference (\u0026clock_id) to the support function - this is important for internal logic we’ll see later.\nThe Core Logic: _POSIX_Condition_variables_Wait_support Now let’s dive into the heart of the implementation in condwaitsupp.c. The function begins with variable declarations:\nint _POSIX_Condition_variables_Wait_support( pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime, clockid_t *clockid ) { POSIX_Condition_variables_Control *the_cond; unsigned long flags; Thread_queue_Context queue_context; int error; Thread_Control *executing; Getting the Internal Condition Variable Object The first step is to get the internal RTEMS representation:\nthe_cond = _POSIX_Condition_variables_Get( cond ); POSIX_CONDITION_VARIABLES_VALIDATE_OBJECT( the_cond, flags ); The _POSIX_Condition_variables_Get function simply casts the pthread condition variable to RTEMS’s internal type:\nstatic inline POSIX_Condition_variables_Control *_POSIX_Condition_variables_Get( pthread_cond_t *cond ) { return (POSIX_Condition_variables_Control *) cond; } The POSIX_CONDITION_VARIABLES_VALIDATE_OBJECT macro performs validation:\nChecks if the_cond is not NULL Extracts and validates the magic number to ensure proper initialization Handles auto-initialization if needed Copies the flags from the condition variable object Thread Queue Context Initialization _Thread_queue_Context_initialize( \u0026queue_context ); This function initializes the queue context structure that will be used for thread queuing operations. In basic configurations (no SMP or debug mode), this is essentially a no-op.\nDetermining the Operation Type The function needs to determine which pthread function variant is being called based on the parameters:\npthread_cond_wait: No timeout (abstime == NULL) pthread_cond_timedwait: Has timeout, no explicit clock pthread_cond_clockwait: Has timeout and explicit clock Case 1: pthread_cond_clockwait (abstime != NULL \u0026\u0026 clockid != NULL) if ( abstime != NULL ) { _Thread_queue_Context_set_timeout_argument( \u0026queue_context, abstime, true ); if ( clockid != NULL ) { if ( *clockid == CLOCK_MONOTONIC ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _POSIX_Condition_variables_Enqueue_with_timeout_monotonic ); } else { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _POSIX_Condition_variables_Enqueue_with_timeout_realtime ); } } // ... (timedwait case follows) } When clockid is not NULL, we’re in the clockwait variant. The function sets up the appropriate timeout callback based on the clock type.\nCase 2: pthread_cond_timedwait (abstime != NULL \u0026\u0026 clockid == NULL) else { if ( _POSIX_Condition_variables_Get_clock( flags ) == CLOCK_MONOTONIC ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _POSIX_Condition_variables_Enqueue_with_timeout_monotonic ); } else { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _POSIX_Condition_variables_Enqueue_with_timeout_realtime ); } } For timed wait, the clock is determined from the condition variable’s attributes (set via pthread_condattr_setclock). The clock information is stored in the flags field of the condition variable.\nCase 3: pthread_cond_wait (abstime == NULL) else { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _POSIX_Condition_variables_Enqueue_no_timeout ); } For the simple wait case, no timeout is needed.\nThe Enqueue Timeout Functions Now let’s understand what these enqueue callback functions do. They are called when a thread needs to be added to the condition variable’s waiting queue. Once the thread is enqueued, it enters a waiting state where it releases the mutex and can be awakened by one of three mechanisms:\nTimeout expiration (for pthread_cond_clockwait and pthread_cond_timedwait) Signal from another thread via pthread_cond_signal() Broadcast from another thread via pthread_cond_broadcast() The key insight is that these enqueue functions perform two critical operations atomically:\nSet up the timeout mechanism (if needed) Release the mutex so other threads can acquire it and potentially signal the condition No Timeout Version static void _POSIX_Condition_variables_Enqueue_no_timeout( Thread_queue_Queue *queue, Thread_Control *the_thread, Per_CPU_Control *cpu_self, Thread_queue_Context *queue_context ) { _POSIX_Condition_variables_Mutex_unlock( queue, the_thread, queue_context ); } This simply unlocks the mutex - no timeout setup is needed.\nMonotonic Timeout Version static void _POSIX_Condition_variables_Enqueue_with_timeout_monotonic( Thread_queue_Queue *queue, Thread_Control *the_thread, Per_CPU_Control *cpu_self, Thread_queue_Context *queue_context ) { _Thread_queue_Add_timeout_monotonic_timespec( queue, the_thread, cpu_self, queue_context ); _POSIX_Condition_variables_Mutex_unlock( queue, the_thread, queue_context ); } This sets up a monotonic timeout and then unlocks the mutex.\nUnderstanding Clock Types: Monotonic vs Realtime Before we continue, let’s understand the fundamental difference between these clock types:\nCLOCK_REALTIME Wall Clock Time: Represents actual calendar time (e.g., “January 15, 2025, 3:30 PM”) Can Jump: System administrators can change it, NTP can adjust it Affected by Time Changes: If someone sets the system clock back 1 hour, timeouts based on realtime will be extended by 1 hour Use Case: When you need timeouts based on absolute calendar time Example Problem:\n// It's 3:00 PM, timeout set for 3:05 PM pthread_cond_clockwait(\u0026cond, \u0026mutex, CLOCK_REALTIME, \u0026timeout_3_05_PM); // At 3:02 PM, admin sets system clock back to 2:00 PM // Your timeout now won't fire until 3:05 PM \"again\" - 1 hour and 3 minutes later! CLOCK_MONOTONIC System Uptime: Represents time since system boot Never Goes Backward: Guaranteed to be monotonically increasing Immune to Time Changes: System clock adjustments don’t affect it Use Case: When you need reliable relative timeouts Example Benefit:\n// System uptime: 50000 seconds, timeout set for +5 seconds (50005 seconds) pthread_cond_clockwait(\u0026cond, \u0026mutex, CLOCK_MONOTONIC, \u0026timeout_in_5_sec); // Even if admin changes wall clock, timeout still fires in exactly 5 seconds When to Use Which? Use CLOCK_REALTIME when:\nYou need to wake up at a specific calendar time Coordinating with external systems using wall clock time Example: “Wake up at midnight to run daily backup” Use CLOCK_MONOTONIC when:\nYou need reliable relative timeouts Measuring elapsed time or intervals Most application timeouts Example: “Timeout after 30 seconds of waiting” Realtime Timeout Version static void _POSIX_Condition_variables_Enqueue_with_timeout_realtime( Thread_queue_Queue *queue, Thread_Control *the_thread, Per_CPU_Control *cpu_self, Thread_queue_Context *queue_context ) { _Thread_queue_Add_timeout_realtime_timespec( queue, the_thread, cpu_self, queue_context ); _POSIX_Condition_variables_Mutex_unlock( queue, the_thread, queue_context ); } This sets up a realtime timeout and then unlocks the mutex.\nThe Critical Mutex Unlock Function All enqueue functions call _POSIX_Condition_variables_Mutex_unlock:\nstatic void _POSIX_Condition_variables_Mutex_unlock( Thread_queue_Queue *queue, Thread_Control *the_thread, Thread_queue_Context *queue_context ) { POSIX_Condition_variables_Control *the_cond; int mutex_error; the_cond = POSIX_CONDITION_VARIABLE_OF_THREAD_QUEUE_QUEUE( queue ); mutex_error = pthread_mutex_unlock( the_cond-\u003emutex ); if ( mutex_error != 0 ) { /* * Historically, we ignored the unlock status since the behavior * is undefined by POSIX. But GNU/Linux returns EPERM in this * case, so we follow their lead. */ _Assert( mutex_error == EINVAL || mutex_error == EPERM ); _Thread_Continue( the_thread, STATUS_NOT_OWNER ); } } This function is crucial because it handles the atomic release of the mutex when the thread goes to sleep. If the mutex unlock fails, the thread is continued with an error status instead of being blocked.\nThread Queuing and Waiting After setting up the timeout callbacks, the main function continues with:\nexecuting = _POSIX_Condition_variables_Acquire( the_cond, \u0026queue_context ); if ( the_cond-\u003emutex != POSIX_CONDITION_VARIABLES_NO_MUTEX \u0026\u0026 the_cond-\u003emutex != mutex ) { _POSIX_Condition_variables_Release( the_cond, \u0026queue_context ); return EINVAL; } the_cond-\u003emutex = mutex; _Thread_queue_Context_set_thread_state( \u0026queue_context, STATES_WAITING_FOR_CONDITION_VARIABLE ); _Thread_queue_Enqueue( \u0026the_cond-\u003eQueue.Queue, POSIX_CONDITION_VARIABLES_TQ_OPERATIONS, executing, \u0026queue_context ); This section:\nAcquires the condition variable’s lock to ensure thread-safe access to the condition variable’s internal state Validates that the mutex is consistent (the same mutex must be used across all waiters) Associates the mutex with the condition variable Sets the thread state to waiting for condition variable Enqueues the thread, which triggers the timeout callback we set up earlier Error Handling and Cleanup Finally, the function handles the result:\nerror = _POSIX_Get_error_after_wait( executing ); /* * If the thread is interrupted, while in the thread queue, by * a POSIX signal, then pthread_cond_wait returns spuriously, * according to the POSIX standard. */ if ( error == EINTR ) { error = 0; } /* * When we get here the dispatch disable level is 0. */ if ( error != EPERM ) { int mutex_error; mutex_error = pthread_mutex_lock( mutex ); if ( mutex_error != 0 ) { _Assert( mutex_error == EINVAL ); error = EINVAL; } } return error; This handles:\nConverting thread queue errors to POSIX error codes Handling spurious wakeups from signals (the function returns normally, requiring applications to use condition variables in loops) Re-acquiring the mutex after waking up (unless there was a permission error like EPERM) Summary The pthread condition variable implementation in RTEMS demonstrates several key concepts:\nUnified Implementation: One support function handles all three variants (wait, timedwait, clockwait) Callback-based Timeout: Different timeout behaviors are handled through function pointers Atomic Mutex Operations: The mutex is unlocked atomically when the thread goes to sleep Thread Queue Management: The underlying thread queue system handles the actual blocking and wakeup logic Key Takeaways For Application Developers Always use condition variables in loops: Spurious wakeups are a feature, not a bug Understand timeout semantics: Choose between monotonic and realtime clocks based on your needs Handle all error cases: Including ETIMEDOUT, EINVAL, and EPERM The Complete Flow Summary API Entry: pthread_cond_clockwait() validates parameters and delegates to support function Operation Detection: Support function determines which variant is being called based on parameters Callback Setup: Appropriate timeout callback is selected (none, monotonic, or realtime) Thread Queuing: Thread is enqueued on condition variable with timeout setup and mutex unlock Waiting: Thread sleeps until woken by signal, broadcast, timeout, or signal interruption Wakeup Processing: Error codes are converted, spurious wakeups handled, and mutex re-acquired Return: Function returns with appropriate status and mutex locked (if successful) ",
  "wordCount" : "1584",
  "inLanguage": "en",
  "datePublished": "2025-07-06T01:10:41+03:00",
  "dateModified": "2025-07-06T01:10:41+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mez3n.github.io/mez3n.blog/posts/pthreadinternals/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mez3n's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mez3n.github.io/mez3n.blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mez3n.github.io/mez3n.blog/" accesskey="h" title="Mez3n&#39;s Blog (Alt + H)">Mez3n&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Pthread Internals: How Condition Variables Work
    </h1>
    <div class="post-meta"><span title='2025-07-06 01:10:41 +0300 EEST'>July 6, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="understanding-pthread-condition-variables-from-the-inside">Understanding Pthread Condition Variables from the Inside<a hidden class="anchor" aria-hidden="true" href="#understanding-pthread-condition-variables-from-the-inside">#</a></h1>
<p>In this blog post, we&rsquo;ll explore how pthread synchronization primitives work internally, focusing on condition variables. We&rsquo;ll dive deep into the RTEMS implementation to understand how <code>pthread_cond_wait</code>, <code>pthread_cond_timedwait</code>, and <code>pthread_cond_clockwait</code> work under the hood.</p>
<h2 id="why-start-with-pthread_cond_clockwait">Why Start with pthread_cond_clockwait?<a hidden class="anchor" aria-hidden="true" href="#why-start-with-pthread_cond_clockwait">#</a></h2>
<p>We&rsquo;ll begin with <code>pthread_cond_clockwait</code> because it&rsquo;s the most comprehensive function - it includes mutex locking, timeout handling, and clock selection. Understanding this function will help us grasp how the simpler variants work.</p>
<h2 id="the-entry-point-condclockwaitc">The Entry Point: condclockwait.c<a hidden class="anchor" aria-hidden="true" href="#the-entry-point-condclockwaitc">#</a></h2>
<p>Let&rsquo;s start by examining the implementation of <code>pthread_cond_clockwait</code> in <code>condclockwait.c</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_cond_clockwait</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_cond_t</span>        <span style="color:#f92672">*</span>cond,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_mutex_t</span>       <span style="color:#f92672">*</span>mutex,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>              clock_id,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">!=</span> CLOCK_MONOTONIC <span style="color:#f92672">&amp;&amp;</span> clock_id <span style="color:#f92672">!=</span> CLOCK_REALTIME ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Wait_support</span>(
</span></span><span style="display:flex;"><span>    cond,
</span></span><span style="display:flex;"><span>    mutex,
</span></span><span style="display:flex;"><span>    abstime,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>clock_id
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="parameter-validation">Parameter Validation<a hidden class="anchor" aria-hidden="true" href="#parameter-validation">#</a></h3>
<p>The function performs critical validation checks as required by the <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/pthread_cond_clockwait.html">POSIX specification</a>:</p>
<ol>
<li><strong>Timeout validation</strong>: <code>abstime</code> cannot be NULL for a timed wait</li>
<li><strong>Clock validation</strong>: Only <code>CLOCK_MONOTONIC</code> and <code>CLOCK_REALTIME</code> are supported</li>
</ol>
<p>Notice that <code>clock_id</code> is passed as a reference (<code>&amp;clock_id</code>) to the support function - this is important for internal logic we&rsquo;ll see later.</p>
<h2 id="the-core-logic-_posix_condition_variables_wait_support">The Core Logic: _POSIX_Condition_variables_Wait_support<a hidden class="anchor" aria-hidden="true" href="#the-core-logic-_posix_condition_variables_wait_support">#</a></h2>
<p>Now let&rsquo;s dive into the heart of the implementation in <code>condwaitsupp.c</code>. The function begins with variable declarations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Wait_support</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_cond_t</span>        <span style="color:#f92672">*</span>cond,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_mutex_t</span>       <span style="color:#f92672">*</span>mutex,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>             <span style="color:#f92672">*</span>clockid
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  POSIX_Condition_variables_Control <span style="color:#f92672">*</span>the_cond;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>                      flags;
</span></span><span style="display:flex;"><span>  Thread_queue_Context               queue_context;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span>                                error;
</span></span><span style="display:flex;"><span>  Thread_Control                    <span style="color:#f92672">*</span>executing;
</span></span></code></pre></div><h3 id="getting-the-internal-condition-variable-object">Getting the Internal Condition Variable Object<a hidden class="anchor" aria-hidden="true" href="#getting-the-internal-condition-variable-object">#</a></h3>
<p>The first step is to get the internal RTEMS representation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>the_cond <span style="color:#f92672">=</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Get</span>( cond );
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">POSIX_CONDITION_VARIABLES_VALIDATE_OBJECT</span>( the_cond, flags );
</span></span></code></pre></div><p>The <code>_POSIX_Condition_variables_Get</code> function simply casts the pthread condition variable to RTEMS&rsquo;s internal type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> POSIX_Condition_variables_Control <span style="color:#f92672">*</span><span style="color:#a6e22e">_POSIX_Condition_variables_Get</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_cond_t</span> <span style="color:#f92672">*</span>cond
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (POSIX_Condition_variables_Control <span style="color:#f92672">*</span>) cond;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>POSIX_CONDITION_VARIABLES_VALIDATE_OBJECT</code> macro performs validation:</p>
<ul>
<li>Checks if <code>the_cond</code> is not NULL</li>
<li>Extracts and validates the magic number to ensure proper initialization</li>
<li>Handles auto-initialization if needed</li>
<li>Copies the flags from the condition variable object</li>
</ul>
<h3 id="thread-queue-context-initialization">Thread Queue Context Initialization<a hidden class="anchor" aria-hidden="true" href="#thread-queue-context-initialization">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">_Thread_queue_Context_initialize</span>( <span style="color:#f92672">&amp;</span>queue_context );
</span></span></code></pre></div><p>This function initializes the queue context structure that will be used for thread queuing operations. In basic configurations (no SMP or debug mode), this is essentially a no-op.</p>
<h2 id="determining-the-operation-type">Determining the Operation Type<a hidden class="anchor" aria-hidden="true" href="#determining-the-operation-type">#</a></h2>
<p>The function needs to determine which pthread function variant is being called based on the parameters:</p>
<ul>
<li><code>pthread_cond_wait</code>: No timeout (<code>abstime == NULL</code>)</li>
<li><code>pthread_cond_timedwait</code>: Has timeout, no explicit clock</li>
<li><code>pthread_cond_clockwait</code>: Has timeout and explicit clock</li>
</ul>
<h3 id="case-1-pthread_cond_clockwait-abstime--null--clockid--null">Case 1: pthread_cond_clockwait (abstime != NULL &amp;&amp; clockid != NULL)<a hidden class="anchor" aria-hidden="true" href="#case-1-pthread_cond_clockwait-abstime--null--clockid--null">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">!=</span> NULL ) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_set_timeout_argument</span>( <span style="color:#f92672">&amp;</span>queue_context, abstime, true );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( clockid <span style="color:#f92672">!=</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">*</span>clockid <span style="color:#f92672">==</span> CLOCK_MONOTONIC ) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>        _POSIX_Condition_variables_Enqueue_with_timeout_monotonic
</span></span><span style="display:flex;"><span>      );
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>        _POSIX_Condition_variables_Enqueue_with_timeout_realtime
</span></span><span style="display:flex;"><span>      );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// ... (timedwait case follows)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>When <code>clockid</code> is not NULL, we&rsquo;re in the <code>clockwait</code> variant. The function sets up the appropriate timeout callback based on the clock type.</p>
<h3 id="case-2-pthread_cond_timedwait-abstime--null--clockid--null">Case 2: pthread_cond_timedwait (abstime != NULL &amp;&amp; clockid == NULL)<a hidden class="anchor" aria-hidden="true" href="#case-2-pthread_cond_timedwait-abstime--null--clockid--null">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">_POSIX_Condition_variables_Get_clock</span>( flags ) <span style="color:#f92672">==</span> CLOCK_MONOTONIC ) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>      _POSIX_Condition_variables_Enqueue_with_timeout_monotonic
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>      _POSIX_Condition_variables_Enqueue_with_timeout_realtime
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For timed wait, the clock is determined from the condition variable&rsquo;s attributes (set via <code>pthread_condattr_setclock</code>). The clock information is stored in the flags field of the condition variable.</p>
<h3 id="case-3-pthread_cond_wait-abstime--null">Case 3: pthread_cond_wait (abstime == NULL)<a hidden class="anchor" aria-hidden="true" href="#case-3-pthread_cond_wait-abstime--null">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>    _POSIX_Condition_variables_Enqueue_no_timeout
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>For the simple wait case, no timeout is needed.</p>
<h2 id="the-enqueue-timeout-functions">The Enqueue Timeout Functions<a hidden class="anchor" aria-hidden="true" href="#the-enqueue-timeout-functions">#</a></h2>
<p>Now let&rsquo;s understand what these enqueue callback functions do. They are called when a thread needs to be added to the condition variable&rsquo;s waiting queue. Once the thread is enqueued, it enters a waiting state where it releases the mutex and can be awakened by one of three mechanisms:</p>
<ol>
<li><strong>Timeout expiration</strong> (for <code>pthread_cond_clockwait</code> and <code>pthread_cond_timedwait</code>)</li>
<li><strong>Signal from another thread</strong> via <code>pthread_cond_signal()</code></li>
<li><strong>Broadcast from another thread</strong> via <code>pthread_cond_broadcast()</code></li>
</ol>
<p>The key insight is that these enqueue functions perform two critical operations atomically:</p>
<ul>
<li>Set up the timeout mechanism (if needed)</li>
<li>Release the mutex so other threads can acquire it and potentially signal the condition</li>
</ul>
<h3 id="no-timeout-version">No Timeout Version<a hidden class="anchor" aria-hidden="true" href="#no-timeout-version">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Enqueue_no_timeout</span>(
</span></span><span style="display:flex;"><span>  Thread_queue_Queue   <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>the_thread,
</span></span><span style="display:flex;"><span>  Per_CPU_Control      <span style="color:#f92672">*</span>cpu_self,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_POSIX_Condition_variables_Mutex_unlock</span>( queue, the_thread, queue_context );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This simply unlocks the mutex - no timeout setup is needed.</p>
<h3 id="monotonic-timeout-version">Monotonic Timeout Version<a hidden class="anchor" aria-hidden="true" href="#monotonic-timeout-version">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Enqueue_with_timeout_monotonic</span>(
</span></span><span style="display:flex;"><span>  Thread_queue_Queue   <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>the_thread,
</span></span><span style="display:flex;"><span>  Per_CPU_Control      <span style="color:#f92672">*</span>cpu_self,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Add_timeout_monotonic_timespec</span>(
</span></span><span style="display:flex;"><span>    queue,
</span></span><span style="display:flex;"><span>    the_thread,
</span></span><span style="display:flex;"><span>    cpu_self,
</span></span><span style="display:flex;"><span>    queue_context
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_POSIX_Condition_variables_Mutex_unlock</span>( queue, the_thread, queue_context );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This sets up a monotonic timeout and then unlocks the mutex.</p>
<h3 id="understanding-clock-types-monotonic-vs-realtime">Understanding Clock Types: Monotonic vs Realtime<a hidden class="anchor" aria-hidden="true" href="#understanding-clock-types-monotonic-vs-realtime">#</a></h3>
<p>Before we continue, let&rsquo;s understand the fundamental difference between these clock types:</p>
<h4 id="clock_realtime">CLOCK_REALTIME<a hidden class="anchor" aria-hidden="true" href="#clock_realtime">#</a></h4>
<ul>
<li><strong>Wall Clock Time</strong>: Represents actual calendar time (e.g., &ldquo;January 15, 2025, 3:30 PM&rdquo;)</li>
<li><strong>Can Jump</strong>: System administrators can change it, NTP can adjust it</li>
<li><strong>Affected by Time Changes</strong>: If someone sets the system clock back 1 hour, timeouts based on realtime will be extended by 1 hour</li>
<li><strong>Use Case</strong>: When you need timeouts based on absolute calendar time</li>
</ul>
<p><strong>Example Problem:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// It&#39;s 3:00 PM, timeout set for 3:05 PM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_cond_clockwait</span>(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex, CLOCK_REALTIME, <span style="color:#f92672">&amp;</span>timeout_3_05_PM);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// At 3:02 PM, admin sets system clock back to 2:00 PM
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Your timeout now won&#39;t fire until 3:05 PM &#34;again&#34; - 1 hour and 3 minutes later!
</span></span></span></code></pre></div><h4 id="clock_monotonic">CLOCK_MONOTONIC<a hidden class="anchor" aria-hidden="true" href="#clock_monotonic">#</a></h4>
<ul>
<li><strong>System Uptime</strong>: Represents time since system boot</li>
<li><strong>Never Goes Backward</strong>: Guaranteed to be monotonically increasing</li>
<li><strong>Immune to Time Changes</strong>: System clock adjustments don&rsquo;t affect it</li>
<li><strong>Use Case</strong>: When you need reliable relative timeouts</li>
</ul>
<p><strong>Example Benefit:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// System uptime: 50000 seconds, timeout set for +5 seconds (50005 seconds)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_cond_clockwait</span>(<span style="color:#f92672">&amp;</span>cond, <span style="color:#f92672">&amp;</span>mutex, CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>timeout_in_5_sec);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Even if admin changes wall clock, timeout still fires in exactly 5 seconds
</span></span></span></code></pre></div><h4 id="when-to-use-which">When to Use Which?<a hidden class="anchor" aria-hidden="true" href="#when-to-use-which">#</a></h4>
<ul>
<li>
<p><strong>Use CLOCK_REALTIME</strong> when:</p>
<ul>
<li>You need to wake up at a specific calendar time</li>
<li>Coordinating with external systems using wall clock time</li>
<li>Example: &ldquo;Wake up at midnight to run daily backup&rdquo;</li>
</ul>
</li>
<li>
<p><strong>Use CLOCK_MONOTONIC</strong> when:</p>
<ul>
<li>You need reliable relative timeouts</li>
<li>Measuring elapsed time or intervals</li>
<li>Most application timeouts</li>
<li>Example: &ldquo;Timeout after 30 seconds of waiting&rdquo;</li>
</ul>
</li>
</ul>
<h3 id="realtime-timeout-version">Realtime Timeout Version<a hidden class="anchor" aria-hidden="true" href="#realtime-timeout-version">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Enqueue_with_timeout_realtime</span>(
</span></span><span style="display:flex;"><span>  Thread_queue_Queue   <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>the_thread,
</span></span><span style="display:flex;"><span>  Per_CPU_Control      <span style="color:#f92672">*</span>cpu_self,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Add_timeout_realtime_timespec</span>(
</span></span><span style="display:flex;"><span>    queue,
</span></span><span style="display:flex;"><span>    the_thread,
</span></span><span style="display:flex;"><span>    cpu_self,
</span></span><span style="display:flex;"><span>    queue_context
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_POSIX_Condition_variables_Mutex_unlock</span>( queue, the_thread, queue_context );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This sets up a realtime timeout and then unlocks the mutex.</p>
<h2 id="the-critical-mutex-unlock-function">The Critical Mutex Unlock Function<a hidden class="anchor" aria-hidden="true" href="#the-critical-mutex-unlock-function">#</a></h2>
<p>All enqueue functions call <code>_POSIX_Condition_variables_Mutex_unlock</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Mutex_unlock</span>(
</span></span><span style="display:flex;"><span>  Thread_queue_Queue   <span style="color:#f92672">*</span>queue,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>the_thread,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  POSIX_Condition_variables_Control <span style="color:#f92672">*</span>the_cond;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span>                                mutex_error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  the_cond <span style="color:#f92672">=</span> <span style="color:#a6e22e">POSIX_CONDITION_VARIABLE_OF_THREAD_QUEUE_QUEUE</span>( queue );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mutex_error <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_unlock</span>( the_cond<span style="color:#f92672">-&gt;</span>mutex );
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( mutex_error <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> ) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  Historically, we ignored the unlock status since the behavior
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  is undefined by POSIX. But GNU/Linux returns EPERM in this
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     *  case, so we follow their lead.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Assert</span>( mutex_error <span style="color:#f92672">==</span> EINVAL <span style="color:#f92672">||</span> mutex_error <span style="color:#f92672">==</span> EPERM );
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_Continue</span>( the_thread, STATUS_NOT_OWNER );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function is crucial because it handles the atomic release of the mutex when the thread goes to sleep. If the mutex unlock fails, the thread is continued with an error status instead of being blocked.</p>
<h2 id="thread-queuing-and-waiting">Thread Queuing and Waiting<a hidden class="anchor" aria-hidden="true" href="#thread-queuing-and-waiting">#</a></h2>
<p>After setting up the timeout callbacks, the main function continues with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>executing <span style="color:#f92672">=</span> <span style="color:#a6e22e">_POSIX_Condition_variables_Acquire</span>( the_cond, <span style="color:#f92672">&amp;</span>queue_context );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( the_cond<span style="color:#f92672">-&gt;</span>mutex <span style="color:#f92672">!=</span> POSIX_CONDITION_VARIABLES_NO_MUTEX <span style="color:#f92672">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>     the_cond<span style="color:#f92672">-&gt;</span>mutex <span style="color:#f92672">!=</span> mutex ) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_POSIX_Condition_variables_Release</span>( the_cond, <span style="color:#f92672">&amp;</span>queue_context );
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>the_cond<span style="color:#f92672">-&gt;</span>mutex <span style="color:#f92672">=</span> mutex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_Thread_queue_Context_set_thread_state</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>  STATES_WAITING_FOR_CONDITION_VARIABLE
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">_Thread_queue_Enqueue</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&amp;</span>the_cond<span style="color:#f92672">-&gt;</span>Queue.Queue,
</span></span><span style="display:flex;"><span>  POSIX_CONDITION_VARIABLES_TQ_OPERATIONS,
</span></span><span style="display:flex;"><span>  executing,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&amp;</span>queue_context
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p>This section:</p>
<ol>
<li>Acquires the condition variable&rsquo;s lock to ensure thread-safe access to the condition variable&rsquo;s internal state</li>
<li>Validates that the mutex is consistent (the same mutex must be used across all waiters)</li>
<li>Associates the mutex with the condition variable</li>
<li>Sets the thread state to waiting for condition variable</li>
<li>Enqueues the thread, which triggers the timeout callback we set up earlier</li>
</ol>
<h2 id="error-handling-and-cleanup">Error Handling and Cleanup<a hidden class="anchor" aria-hidden="true" href="#error-handling-and-cleanup">#</a></h2>
<p>Finally, the function handles the result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>error <span style="color:#f92672">=</span> <span style="color:#a6e22e">_POSIX_Get_error_after_wait</span>( executing );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  If the thread is interrupted, while in the thread queue, by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  a POSIX signal, then pthread_cond_wait returns spuriously,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  according to the POSIX standard.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( error <span style="color:#f92672">==</span> EINTR ) {
</span></span><span style="display:flex;"><span>  error <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *  When we get here the dispatch disable level is 0.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( error <span style="color:#f92672">!=</span> EPERM ) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> mutex_error;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  mutex_error <span style="color:#f92672">=</span> <span style="color:#a6e22e">pthread_mutex_lock</span>( mutex );
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( mutex_error <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> ) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Assert</span>( mutex_error <span style="color:#f92672">==</span> EINVAL );
</span></span><span style="display:flex;"><span>    error <span style="color:#f92672">=</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> error;
</span></span></code></pre></div><p>This handles:</p>
<ul>
<li>Converting thread queue errors to POSIX error codes</li>
<li>Handling spurious wakeups from signals (the function returns normally, requiring applications to use condition variables in loops)</li>
<li>Re-acquiring the mutex after waking up (unless there was a permission error like <code>EPERM</code>)</li>
</ul>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>The pthread condition variable implementation in RTEMS demonstrates several key concepts:</p>
<ol>
<li><strong>Unified Implementation</strong>: One support function handles all three variants (wait, timedwait, clockwait)</li>
<li><strong>Callback-based Timeout</strong>: Different timeout behaviors are handled through function pointers</li>
<li><strong>Atomic Mutex Operations</strong>: The mutex is unlocked atomically when the thread goes to sleep</li>
<li><strong>Thread Queue Management</strong>: The underlying thread queue system handles the actual blocking and wakeup logic</li>
</ol>
<h2 id="key-takeaways">Key Takeaways<a hidden class="anchor" aria-hidden="true" href="#key-takeaways">#</a></h2>
<h3 id="for-application-developers">For Application Developers<a hidden class="anchor" aria-hidden="true" href="#for-application-developers">#</a></h3>
<ul>
<li><strong>Always use condition variables in loops</strong>: Spurious wakeups are a feature, not a bug</li>
<li><strong>Understand timeout semantics</strong>: Choose between monotonic and realtime clocks based on your needs</li>
<li><strong>Handle all error cases</strong>: Including <code>ETIMEDOUT</code>, <code>EINVAL</code>, and <code>EPERM</code></li>
</ul>
<h3 id="the-complete-flow-summary">The Complete Flow Summary<a hidden class="anchor" aria-hidden="true" href="#the-complete-flow-summary">#</a></h3>
<ol>
<li><strong>API Entry</strong>: <code>pthread_cond_clockwait()</code> validates parameters and delegates to support function</li>
<li><strong>Operation Detection</strong>: Support function determines which variant is being called based on parameters</li>
<li><strong>Callback Setup</strong>: Appropriate timeout callback is selected (none, monotonic, or realtime)</li>
<li><strong>Thread Queuing</strong>: Thread is enqueued on condition variable with timeout setup and mutex unlock</li>
<li><strong>Waiting</strong>: Thread sleeps until woken by signal, broadcast, timeout, or signal interruption</li>
<li><strong>Wakeup Processing</strong>: Error codes are converted, spurious wakeups handled, and mutex re-acquired</li>
<li><strong>Return</strong>: Function returns with appropriate status and mutex locked (if successful)</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://mez3n.github.io/mez3n.blog/">Mez3n&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
