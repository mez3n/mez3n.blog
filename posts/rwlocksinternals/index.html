<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work | Mez3n&#39;s Blog</title>
<meta name="keywords" content="pthread, RTEMS, synchronization, rwlock, internals">
<meta name="description" content="Understanding Pthread Reader-Writer Lock Clock Functions from the Inside
In this blog post, we&rsquo;ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We&rsquo;ll dive deep into the RTEMS implementation to understand how pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock work under the hood.
Why Reader-Writer Locks with Clock Support?
Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.">
<meta name="author" content="">
<link rel="canonical" href="https://mez3n.github.io/mez3n.blog/posts/rwlocksinternals/">
<link crossorigin="anonymous" href="/mez3n.blog/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mez3n.github.io/mez3n.blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mez3n.github.io/mez3n.blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mez3n.github.io/mez3n.blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mez3n.github.io/mez3n.blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://mez3n.github.io/mez3n.blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://mez3n.github.io/mez3n.blog/posts/rwlocksinternals/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://mez3n.github.io/mez3n.blog/posts/rwlocksinternals/">
  <meta property="og:site_name" content="Mez3n&#39;s Blog">
  <meta property="og:title" content="Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work">
  <meta property="og:description" content="Understanding Pthread Reader-Writer Lock Clock Functions from the Inside In this blog post, we’ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We’ll dive deep into the RTEMS implementation to understand how pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock work under the hood.
Why Reader-Writer Locks with Clock Support? Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-16T21:58:29+03:00">
    <meta property="article:modified_time" content="2025-07-16T21:58:29+03:00">
    <meta property="article:tag" content="Pthread">
    <meta property="article:tag" content="RTEMS">
    <meta property="article:tag" content="Synchronization">
    <meta property="article:tag" content="Rwlock">
    <meta property="article:tag" content="Internals">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work">
<meta name="twitter:description" content="Understanding Pthread Reader-Writer Lock Clock Functions from the Inside
In this blog post, we&rsquo;ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We&rsquo;ll dive deep into the RTEMS implementation to understand how pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock work under the hood.
Why Reader-Writer Locks with Clock Support?
Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mez3n.github.io/mez3n.blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work",
      "item": "https://mez3n.github.io/mez3n.blog/posts/rwlocksinternals/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work",
  "name": "Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work",
  "description": "Understanding Pthread Reader-Writer Lock Clock Functions from the Inside In this blog post, we\u0026rsquo;ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We\u0026rsquo;ll dive deep into the RTEMS implementation to understand how pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock work under the hood.\nWhy Reader-Writer Locks with Clock Support? Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.\n",
  "keywords": [
    "pthread", "RTEMS", "synchronization", "rwlock", "internals"
  ],
  "articleBody": "Understanding Pthread Reader-Writer Lock Clock Functions from the Inside In this blog post, we’ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We’ll dive deep into the RTEMS implementation to understand how pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock work under the hood.\nWhy Reader-Writer Locks with Clock Support? Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (pthread_rwlock_clockrdlock and pthread_rwlock_clockwrlock) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.\nThe Entry Points: rwlockclockrdlock.c and rwlockclockwrlock.c Let’s start by examining the implementation of both functions:\npthread_rwlock_clockrdlock int pthread_rwlock_clockrdlock( pthread_rwlock_t *rwlock, clockid_t clock_id, const struct timespec *abstime ) { if ( abstime == NULL ) { return EINVAL; } if ( clock_id != CLOCK_MONOTONIC \u0026\u0026 clock_id != CLOCK_REALTIME ) { return EINVAL; } return _POSIX_RWLock_Rdlock_support( rwlock, abstime, clock_id ); } pthread_rwlock_clockwrlock int pthread_rwlock_clockwrlock( pthread_rwlock_t *rwlock, clockid_t clock_id, const struct timespec *abstime ) { if ( abstime == NULL ) { return EINVAL; } if ( clock_id != CLOCK_MONOTONIC \u0026\u0026 clock_id != CLOCK_REALTIME ) { return EINVAL; } return _POSIX_RWLock_Wrlock_support( rwlock, abstime, clock_id ); } Parameter Validation Both functions perform identical validation checks as required by the POSIX specification:\nTimeout validation: abstime cannot be NULL for a timed lock operation Clock validation: Only CLOCK_MONOTONIC and CLOCK_REALTIME are supported Notice that clock_id is passed as a value (not a pointer) to the support functions - this differs from the condition variable implementation but serves the same purpose.\nThe Core Logic: _POSIX_RWLock_Rdlock_support Let’s dive into the reader lock support function in rwlockrdlock.c. The function begins with variable declarations:\nint _POSIX_RWLock_Rdlock_support( pthread_rwlock_t *rwlock, const struct timespec *abstime, clockid_t clock_id ) { POSIX_RWLock_Control *the_rwlock; Thread_queue_Context queue_context; Status_Control status; Getting the Internal RWLock Object The first step is to get the internal RTEMS representation:\nthe_rwlock = _POSIX_RWLock_Get( rwlock ); POSIX_RWLOCK_VALIDATE_OBJECT( the_rwlock ); The _POSIX_RWLock_Get function simply casts the pthread rwlock to RTEMS’s internal type:\nstatic inline POSIX_RWLock_Control *_POSIX_RWLock_Get( pthread_rwlock_t *rwlock ) { return (POSIX_RWLock_Control *) rwlock; } The POSIX_RWLOCK_VALIDATE_OBJECT macro performs validation:\nChecks if the_rwlock is not NULL Validates the magic number to ensure proper initialization Handles auto-initialization if needed Thread Queue Context Initialization _Thread_queue_Context_initialize( \u0026queue_context ); This function initializes the queue context structure that will be used for thread queuing operations, just like in the condition variable implementation.\nClock-Aware Timeout Setup The function needs to set up the appropriate timeout mechanism based on the clock type:\nif ( abstime != NULL ) { _Thread_queue_Context_set_timeout_argument( \u0026queue_context, abstime, true ); if ( clock_id == CLOCK_MONOTONIC ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _Thread_queue_Add_timeout_monotonic_timespec ); } else if ( clock_id == CLOCK_REALTIME ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _Thread_queue_Add_timeout_realtime_timespec ); } } Understanding the Clock Selection Logic Unlike condition variables which had different functions for different clock types, the RWLock implementation uses a single support function that branches based on the clock_id parameter:\nCLOCK_MONOTONIC: Uses _Thread_queue_Add_timeout_monotonic_timespec CLOCK_REALTIME: Uses _Thread_queue_Add_timeout_realtime_timespec This approach is cleaner and more direct than the condition variable implementation.\nThe Core RWLock Operation After setting up the timeout, the function performs the actual lock operation:\nstatus = _CORE_RWLock_Seize_for_reading( \u0026the_rwlock-\u003eRWLock, _Thread_Executing, \u0026queue_context ); Understanding _CORE_RWLock_Seize_for_reading This function is the heart of the reader lock acquisition logic. Let’s examine what it does:\nStatus_Control _CORE_RWLock_Seize_for_reading( CORE_RWLock_Control *the_rwlock, Thread_Control *executing, Thread_queue_Context *queue_context ) { Thread_Control *owner; owner = the_rwlock-\u003eOwner; if ( owner == NULL ) { /* No owner, we can acquire read lock */ return _CORE_RWLock_Grant_reading_lock( the_rwlock, executing, queue_context ); } if ( _CORE_RWLock_Is_reading( owner ) ) { /* Already held by readers, we can join */ return _CORE_RWLock_Grant_reading_lock( the_rwlock, executing, queue_context ); } /* Writer holds the lock or writers are waiting, we must block */ return _CORE_RWLock_Enqueue_for_reading( the_rwlock, executing, queue_context ); } Reader Lock Acquisition States The reader lock can be acquired immediately in two scenarios:\nNo Owner: The lock is completely free Reader Owned: The lock is already held by one or more readers In both cases, _CORE_RWLock_Grant_reading_lock is called:\nstatic Status_Control _CORE_RWLock_Grant_reading_lock( CORE_RWLock_Control *the_rwlock, Thread_Control *executing, Thread_queue_Context *queue_context ) { if ( the_rwlock-\u003eOwner == NULL ) { /* First reader */ the_rwlock-\u003eOwner = executing; the_rwlock-\u003enumber_of_readers = 1; } else { /* Additional reader */ the_rwlock-\u003enumber_of_readers++; } _Thread_queue_Context_clear_priority_updates( queue_context ); _Thread_queue_Release( \u0026the_rwlock-\u003eQueue, queue_context ); return STATUS_SUCCESSFUL; } This function:\nUpdates the reader count Sets the owner to the first reader (if no previous owner) Releases the queue and returns success Reader Lock Blocking If the lock is held by a writer or writers are waiting, the reader must block:\nstatic Status_Control _CORE_RWLock_Enqueue_for_reading( CORE_RWLock_Control *the_rwlock, Thread_Control *executing, Thread_queue_Context *queue_context ) { return _Thread_queue_Enqueue( \u0026the_rwlock-\u003eQueue.Queue, CORE_RWLOCK_TQ_OPERATIONS, executing, queue_context ); } This is where the timeout callbacks we set up earlier come into play. The thread is enqueued with the appropriate timeout mechanism.\nThe Core Logic: _POSIX_RWLock_Wrlock_support Now let’s examine the writer lock support function in rwlockwrlock.c:\nint _POSIX_RWLock_Wrlock_support( pthread_rwlock_t *rwlock, const struct timespec *abstime, clockid_t clock_id ) { POSIX_RWLock_Control *the_rwlock; Thread_queue_Context queue_context; Status_Control status; the_rwlock = _POSIX_RWLock_Get( rwlock ); POSIX_RWLOCK_VALIDATE_OBJECT( the_rwlock ); _Thread_queue_Context_initialize( \u0026queue_context ); if ( abstime != NULL ) { _Thread_queue_Context_set_timeout_argument( \u0026queue_context, abstime, true ); if ( clock_id == CLOCK_MONOTONIC ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _Thread_queue_Add_timeout_monotonic_timespec ); } else if ( clock_id == CLOCK_REALTIME ) { _Thread_queue_Context_set_enqueue_callout( \u0026queue_context, _Thread_queue_Add_timeout_realtime_timespec ); } } status = _CORE_RWLock_Seize_for_writing( \u0026the_rwlock-\u003eRWLock, _Thread_Executing, \u0026queue_context ); return _POSIX_Get_error( status ); } The writer lock support function follows the same pattern as the reader version but calls _CORE_RWLock_Seize_for_writing instead.\nUnderstanding _CORE_RWLock_Seize_for_writing The writer lock acquisition logic is more restrictive:\nStatus_Control _CORE_RWLock_Seize_for_writing( CORE_RWLock_Control *the_rwlock, Thread_Control *executing, Thread_queue_Context *queue_context ) { Thread_Control *owner; owner = the_rwlock-\u003eOwner; if ( owner == NULL ) { /* No owner, we can acquire write lock */ return _CORE_RWLock_Grant_writing_lock( the_rwlock, executing, queue_context ); } /* Lock is held by someone, we must block */ return _CORE_RWLock_Enqueue_for_writing( the_rwlock, executing, queue_context ); } Writer Lock Acquisition States The writer lock can only be acquired in one scenario:\nNo Owner: The lock is completely free If there’s any owner (reader or writer), the writer must block.\nstatic Status_Control _CORE_RWLock_Grant_writing_lock( CORE_RWLock_Control *the_rwlock, Thread_Control *executing, Thread_queue_Context *queue_context ) { the_rwlock-\u003eOwner = executing; the_rwlock-\u003enumber_of_readers = 0; _Thread_queue_Context_clear_priority_updates( queue_context ); _Thread_queue_Release( \u0026the_rwlock-\u003eQueue, queue_context ); return STATUS_SUCCESSFUL; } This function:\nSets the owner to the writing thread Clears the reader count Releases the queue and returns success Understanding RWLock Timeout Behavior Just like with condition variables, the clock type affects timeout behavior:\nCLOCK_REALTIME Timeouts Wall Clock Time: Timeout is based on absolute calendar time Affected by Time Changes: System clock adjustments can extend or shorten timeouts Use Case: When you need timeouts based on absolute calendar time Example:\nstruct timespec timeout; clock_gettime(CLOCK_REALTIME, \u0026timeout); timeout.tv_sec += 5; // 5 seconds from now // Will timeout in 5 seconds of wall clock time pthread_rwlock_clockrdlock(\u0026rwlock, CLOCK_REALTIME, \u0026timeout); CLOCK_MONOTONIC Timeouts System Uptime: Timeout is based on monotonic system time Immune to Time Changes: System clock adjustments don’t affect it Use Case: When you need reliable relative timeouts Example:\nstruct timespec timeout; clock_gettime(CLOCK_MONOTONIC, \u0026timeout); timeout.tv_sec += 5; // 5 seconds from now // Will timeout in exactly 5 seconds regardless of system clock changes pthread_rwlock_clockrdlock(\u0026rwlock, CLOCK_MONOTONIC, \u0026timeout); Thread Queue Management and Priority RWLocks implement a sophisticated queuing system that handles both readers and writers:\nReader Priority Multiple readers can be granted the lock simultaneously New readers can join existing readers without blocking Readers block only when writers are active or waiting Writer Priority Writers get exclusive access Writers block when any owner exists (reader or writer) The queuing system ensures fairness between readers and writers Priority Inheritance The RWLock implementation supports priority inheritance to prevent priority inversion:\n#define CORE_RWLOCK_TQ_OPERATIONS \u0026_Thread_queue_Operations_priority_inherit This ensures that when a high-priority thread blocks on an RWLock, it can temporarily boost the priority of the lock holder.\nError Handling and Return Values Both functions use the same error handling pattern:\nreturn _POSIX_Get_error( status ); The _POSIX_Get_error function converts RTEMS internal status codes to POSIX error codes:\nSTATUS_SUCCESSFUL → 0 STATUS_TIMEOUT → ETIMEDOUT STATUS_UNAVAILABLE → EBUSY STATUS_OBJECT_WAS_DELETED → EINVAL STATUS_DEADLOCK → EDEADLK Comparison with Non-Clock Variants The clock-aware functions provide enhanced timeout control compared to their non-clock counterparts:\nTraditional Timed Functions // Uses clock from rwlock attributes (usually CLOCK_REALTIME) pthread_rwlock_timedrdlock(\u0026rwlock, \u0026timeout); pthread_rwlock_timedwrlock(\u0026rwlock, \u0026timeout); Clock-Aware Functions // Explicit clock selection pthread_rwlock_clockrdlock(\u0026rwlock, CLOCK_MONOTONIC, \u0026timeout); pthread_rwlock_clockwrlock(\u0026rwlock, CLOCK_REALTIME, \u0026timeout); Summary The pthread reader-writer lock clock functions in RTEMS demonstrate several key concepts:\nUnified Timeout Handling: Both reader and writer functions use the same timeout setup mechanism Clock-Specific Callbacks: Different timeout behaviors are handled through appropriate timeout functions Reader-Writer Semantics: Multiple readers can coexist, but writers need exclusive access Priority Inheritance: The implementation prevents priority inversion through priority inheritance Robust Error Handling: Comprehensive error code mapping from internal status to POSIX errors The Complete Flow Summary For Reader Lock: API Entry: pthread_rwlock_clockrdlock() validates parameters and delegates to support function Timeout Setup: Appropriate timeout callback is selected based on clock type Lock Attempt: Check if lock can be acquired immediately (no owner or readers-only) Grant or Block: Either grant the lock immediately or enqueue the thread with timeout Wakeup Processing: When awakened, error codes are converted and returned For Writer Lock: API Entry: pthread_rwlock_clockwrlock() validates parameters and delegates to support function Timeout Setup: Appropriate timeout callback is selected based on clock type Lock Attempt: Check if lock can be acquired immediately (no owner only) Grant or Block: Either grant exclusive access or enqueue the thread with timeout Wakeup Processing: When awakened, error codes are converted and returned This implementation showcases how RTEMS provides robust, real-time capable synchronization primitives while maintaining POSIX compliance and offering advanced features like configurable clock sources for timeout operations.\n",
  "wordCount" : "1594",
  "inLanguage": "en",
  "datePublished": "2025-07-16T21:58:29+03:00",
  "dateModified": "2025-07-16T21:58:29+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mez3n.github.io/mez3n.blog/posts/rwlocksinternals/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Mez3n's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mez3n.github.io/mez3n.blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mez3n.github.io/mez3n.blog/" accesskey="h" title="Mez3n&#39;s Blog (Alt + H)">Mez3n&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Pthread RWLock Internals: How Reader-Writer Lock Clock Functions Work
    </h1>
    <div class="post-meta"><span title='2025-07-16 21:58:29 +0300 EEST'>July 16, 2025</span>

</div>
  </header> 
  <div class="post-content"><h1 id="understanding-pthread-reader-writer-lock-clock-functions-from-the-inside">Understanding Pthread Reader-Writer Lock Clock Functions from the Inside<a hidden class="anchor" aria-hidden="true" href="#understanding-pthread-reader-writer-lock-clock-functions-from-the-inside">#</a></h1>
<p>In this blog post, we&rsquo;ll explore how pthread reader-writer lock synchronization primitives work internally, focusing on the clock-aware variants. We&rsquo;ll dive deep into the RTEMS implementation to understand how <code>pthread_rwlock_clockrdlock</code> and <code>pthread_rwlock_clockwrlock</code> work under the hood.</p>
<h2 id="why-reader-writer-locks-with-clock-support">Why Reader-Writer Locks with Clock Support?<a hidden class="anchor" aria-hidden="true" href="#why-reader-writer-locks-with-clock-support">#</a></h2>
<p>Reader-writer locks (RWLocks) are a powerful synchronization primitive that allows multiple readers to access a resource simultaneously, while ensuring exclusive access for writers. The clock-aware variants (<code>pthread_rwlock_clockrdlock</code> and <code>pthread_rwlock_clockwrlock</code>) add precise timeout control with different clock types, providing more robust and predictable timeout behavior.</p>
<h2 id="the-entry-points-rwlockclockrdlockc-and-rwlockclockwrlockc">The Entry Points: rwlockclockrdlock.c and rwlockclockwrlock.c<a hidden class="anchor" aria-hidden="true" href="#the-entry-points-rwlockclockrdlockc-and-rwlockclockwrlockc">#</a></h2>
<p>Let&rsquo;s start by examining the implementation of both functions:</p>
<h3 id="pthread_rwlock_clockrdlock">pthread_rwlock_clockrdlock<a hidden class="anchor" aria-hidden="true" href="#pthread_rwlock_clockrdlock">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_rwlock_clockrdlock</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_rwlock_t</span>      <span style="color:#f92672">*</span>rwlock,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>              clock_id,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">!=</span> CLOCK_MONOTONIC <span style="color:#f92672">&amp;&amp;</span> clock_id <span style="color:#f92672">!=</span> CLOCK_REALTIME ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_POSIX_RWLock_Rdlock_support</span>(
</span></span><span style="display:flex;"><span>    rwlock,
</span></span><span style="display:flex;"><span>    abstime,
</span></span><span style="display:flex;"><span>    clock_id
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="pthread_rwlock_clockwrlock">pthread_rwlock_clockwrlock<a hidden class="anchor" aria-hidden="true" href="#pthread_rwlock_clockwrlock">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">pthread_rwlock_clockwrlock</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_rwlock_t</span>      <span style="color:#f92672">*</span>rwlock,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>              clock_id,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">!=</span> CLOCK_MONOTONIC <span style="color:#f92672">&amp;&amp;</span> clock_id <span style="color:#f92672">!=</span> CLOCK_REALTIME ) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> EINVAL;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_POSIX_RWLock_Wrlock_support</span>(
</span></span><span style="display:flex;"><span>    rwlock,
</span></span><span style="display:flex;"><span>    abstime,
</span></span><span style="display:flex;"><span>    clock_id
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="parameter-validation">Parameter Validation<a hidden class="anchor" aria-hidden="true" href="#parameter-validation">#</a></h3>
<p>Both functions perform identical validation checks as required by the <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/pthread_rwlock_clockrdlock.html">POSIX specification</a>:</p>
<ol>
<li><strong>Timeout validation</strong>: <code>abstime</code> cannot be NULL for a timed lock operation</li>
<li><strong>Clock validation</strong>: Only <code>CLOCK_MONOTONIC</code> and <code>CLOCK_REALTIME</code> are supported</li>
</ol>
<p>Notice that <code>clock_id</code> is passed as a value (not a pointer) to the support functions - this differs from the condition variable implementation but serves the same purpose.</p>
<h2 id="the-core-logic-_posix_rwlock_rdlock_support">The Core Logic: _POSIX_RWLock_Rdlock_support<a hidden class="anchor" aria-hidden="true" href="#the-core-logic-_posix_rwlock_rdlock_support">#</a></h2>
<p>Let&rsquo;s dive into the reader lock support function in <code>rwlockrdlock.c</code>. The function begins with variable declarations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_POSIX_RWLock_Rdlock_support</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_rwlock_t</span>      <span style="color:#f92672">*</span>rwlock,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>              clock_id
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  POSIX_RWLock_Control <span style="color:#f92672">*</span>the_rwlock;
</span></span><span style="display:flex;"><span>  Thread_queue_Context  queue_context;
</span></span><span style="display:flex;"><span>  Status_Control        status;
</span></span></code></pre></div><h3 id="getting-the-internal-rwlock-object">Getting the Internal RWLock Object<a hidden class="anchor" aria-hidden="true" href="#getting-the-internal-rwlock-object">#</a></h3>
<p>The first step is to get the internal RTEMS representation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>the_rwlock <span style="color:#f92672">=</span> <span style="color:#a6e22e">_POSIX_RWLock_Get</span>( rwlock );
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">POSIX_RWLOCK_VALIDATE_OBJECT</span>( the_rwlock );
</span></span></code></pre></div><p>The <code>_POSIX_RWLock_Get</code> function simply casts the pthread rwlock to RTEMS&rsquo;s internal type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> POSIX_RWLock_Control <span style="color:#f92672">*</span><span style="color:#a6e22e">_POSIX_RWLock_Get</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_rwlock_t</span> <span style="color:#f92672">*</span>rwlock
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> (POSIX_RWLock_Control <span style="color:#f92672">*</span>) rwlock;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>POSIX_RWLOCK_VALIDATE_OBJECT</code> macro performs validation:</p>
<ul>
<li>Checks if <code>the_rwlock</code> is not NULL</li>
<li>Validates the magic number to ensure proper initialization</li>
<li>Handles auto-initialization if needed</li>
</ul>
<h3 id="thread-queue-context-initialization">Thread Queue Context Initialization<a hidden class="anchor" aria-hidden="true" href="#thread-queue-context-initialization">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">_Thread_queue_Context_initialize</span>( <span style="color:#f92672">&amp;</span>queue_context );
</span></span></code></pre></div><p>This function initializes the queue context structure that will be used for thread queuing operations, just like in the condition variable implementation.</p>
<h2 id="clock-aware-timeout-setup">Clock-Aware Timeout Setup<a hidden class="anchor" aria-hidden="true" href="#clock-aware-timeout-setup">#</a></h2>
<p>The function needs to set up the appropriate timeout mechanism based on the clock type:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">!=</span> NULL ) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_set_timeout_argument</span>( <span style="color:#f92672">&amp;</span>queue_context, abstime, true );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">==</span> CLOCK_MONOTONIC ) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>      _Thread_queue_Add_timeout_monotonic_timespec
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">==</span> CLOCK_REALTIME ) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>      _Thread_queue_Add_timeout_realtime_timespec
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="understanding-the-clock-selection-logic">Understanding the Clock Selection Logic<a hidden class="anchor" aria-hidden="true" href="#understanding-the-clock-selection-logic">#</a></h3>
<p>Unlike condition variables which had different functions for different clock types, the RWLock implementation uses a single support function that branches based on the clock_id parameter:</p>
<ul>
<li><strong>CLOCK_MONOTONIC</strong>: Uses <code>_Thread_queue_Add_timeout_monotonic_timespec</code></li>
<li><strong>CLOCK_REALTIME</strong>: Uses <code>_Thread_queue_Add_timeout_realtime_timespec</code></li>
</ul>
<p>This approach is cleaner and more direct than the condition variable implementation.</p>
<h2 id="the-core-rwlock-operation">The Core RWLock Operation<a hidden class="anchor" aria-hidden="true" href="#the-core-rwlock-operation">#</a></h2>
<p>After setting up the timeout, the function performs the actual lock operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>status <span style="color:#f92672">=</span> <span style="color:#a6e22e">_CORE_RWLock_Seize_for_reading</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&amp;</span>the_rwlock<span style="color:#f92672">-&gt;</span>RWLock,
</span></span><span style="display:flex;"><span>  _Thread_Executing,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&amp;</span>queue_context
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><h3 id="understanding-_core_rwlock_seize_for_reading">Understanding _CORE_RWLock_Seize_for_reading<a hidden class="anchor" aria-hidden="true" href="#understanding-_core_rwlock_seize_for_reading">#</a></h3>
<p>This function is the heart of the reader lock acquisition logic. Let&rsquo;s examine what it does:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Status_Control <span style="color:#a6e22e">_CORE_RWLock_Seize_for_reading</span>(
</span></span><span style="display:flex;"><span>  CORE_RWLock_Control  <span style="color:#f92672">*</span>the_rwlock,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>executing,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  Thread_Control <span style="color:#f92672">*</span>owner;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  owner <span style="color:#f92672">=</span> the_rwlock<span style="color:#f92672">-&gt;</span>Owner;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( owner <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* No owner, we can acquire read lock */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_CORE_RWLock_Grant_reading_lock</span>( the_rwlock, executing, queue_context );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">_CORE_RWLock_Is_reading</span>( owner ) ) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Already held by readers, we can join */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_CORE_RWLock_Grant_reading_lock</span>( the_rwlock, executing, queue_context );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Writer holds the lock or writers are waiting, we must block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_CORE_RWLock_Enqueue_for_reading</span>( the_rwlock, executing, queue_context );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="reader-lock-acquisition-states">Reader Lock Acquisition States<a hidden class="anchor" aria-hidden="true" href="#reader-lock-acquisition-states">#</a></h3>
<p>The reader lock can be acquired immediately in two scenarios:</p>
<ol>
<li><strong>No Owner</strong>: The lock is completely free</li>
<li><strong>Reader Owned</strong>: The lock is already held by one or more readers</li>
</ol>
<p>In both cases, <code>_CORE_RWLock_Grant_reading_lock</code> is called:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Status_Control <span style="color:#a6e22e">_CORE_RWLock_Grant_reading_lock</span>(
</span></span><span style="display:flex;"><span>  CORE_RWLock_Control  <span style="color:#f92672">*</span>the_rwlock,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>executing,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( the_rwlock<span style="color:#f92672">-&gt;</span>Owner <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* First reader */</span>
</span></span><span style="display:flex;"><span>    the_rwlock<span style="color:#f92672">-&gt;</span>Owner <span style="color:#f92672">=</span> executing;
</span></span><span style="display:flex;"><span>    the_rwlock<span style="color:#f92672">-&gt;</span>number_of_readers <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Additional reader */</span>
</span></span><span style="display:flex;"><span>    the_rwlock<span style="color:#f92672">-&gt;</span>number_of_readers<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_clear_priority_updates</span>( queue_context );
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Release</span>( <span style="color:#f92672">&amp;</span>the_rwlock<span style="color:#f92672">-&gt;</span>Queue, queue_context );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> STATUS_SUCCESSFUL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function:</p>
<ul>
<li>Updates the reader count</li>
<li>Sets the owner to the first reader (if no previous owner)</li>
<li>Releases the queue and returns success</li>
</ul>
<h3 id="reader-lock-blocking">Reader Lock Blocking<a hidden class="anchor" aria-hidden="true" href="#reader-lock-blocking">#</a></h3>
<p>If the lock is held by a writer or writers are waiting, the reader must block:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Status_Control <span style="color:#a6e22e">_CORE_RWLock_Enqueue_for_reading</span>(
</span></span><span style="display:flex;"><span>  CORE_RWLock_Control  <span style="color:#f92672">*</span>the_rwlock,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>executing,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_Thread_queue_Enqueue</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>the_rwlock<span style="color:#f92672">-&gt;</span>Queue.Queue,
</span></span><span style="display:flex;"><span>    CORE_RWLOCK_TQ_OPERATIONS,
</span></span><span style="display:flex;"><span>    executing,
</span></span><span style="display:flex;"><span>    queue_context
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is where the timeout callbacks we set up earlier come into play. The thread is enqueued with the appropriate timeout mechanism.</p>
<h2 id="the-core-logic-_posix_rwlock_wrlock_support">The Core Logic: _POSIX_RWLock_Wrlock_support<a hidden class="anchor" aria-hidden="true" href="#the-core-logic-_posix_rwlock_wrlock_support">#</a></h2>
<p>Now let&rsquo;s examine the writer lock support function in <code>rwlockwrlock.c</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_POSIX_RWLock_Wrlock_support</span>(
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">pthread_rwlock_t</span>      <span style="color:#f92672">*</span>rwlock,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> timespec <span style="color:#f92672">*</span>abstime,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">clockid_t</span>              clock_id
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  POSIX_RWLock_Control <span style="color:#f92672">*</span>the_rwlock;
</span></span><span style="display:flex;"><span>  Thread_queue_Context  queue_context;
</span></span><span style="display:flex;"><span>  Status_Control        status;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  the_rwlock <span style="color:#f92672">=</span> <span style="color:#a6e22e">_POSIX_RWLock_Get</span>( rwlock );
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">POSIX_RWLOCK_VALIDATE_OBJECT</span>( the_rwlock );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_initialize</span>( <span style="color:#f92672">&amp;</span>queue_context );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( abstime <span style="color:#f92672">!=</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">_Thread_queue_Context_set_timeout_argument</span>( <span style="color:#f92672">&amp;</span>queue_context, abstime, true );
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">==</span> CLOCK_MONOTONIC ) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>        _Thread_queue_Add_timeout_monotonic_timespec
</span></span><span style="display:flex;"><span>      );
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> ( clock_id <span style="color:#f92672">==</span> CLOCK_REALTIME ) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">_Thread_queue_Context_set_enqueue_callout</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>queue_context,
</span></span><span style="display:flex;"><span>        _Thread_queue_Add_timeout_realtime_timespec
</span></span><span style="display:flex;"><span>      );
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  status <span style="color:#f92672">=</span> <span style="color:#a6e22e">_CORE_RWLock_Seize_for_writing</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>the_rwlock<span style="color:#f92672">-&gt;</span>RWLock,
</span></span><span style="display:flex;"><span>    _Thread_Executing,
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&amp;</span>queue_context
</span></span><span style="display:flex;"><span>  );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_POSIX_Get_error</span>( status );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The writer lock support function follows the same pattern as the reader version but calls <code>_CORE_RWLock_Seize_for_writing</code> instead.</p>
<h3 id="understanding-_core_rwlock_seize_for_writing">Understanding _CORE_RWLock_Seize_for_writing<a hidden class="anchor" aria-hidden="true" href="#understanding-_core_rwlock_seize_for_writing">#</a></h3>
<p>The writer lock acquisition logic is more restrictive:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>Status_Control <span style="color:#a6e22e">_CORE_RWLock_Seize_for_writing</span>(
</span></span><span style="display:flex;"><span>  CORE_RWLock_Control  <span style="color:#f92672">*</span>the_rwlock,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>executing,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  Thread_Control <span style="color:#f92672">*</span>owner;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  owner <span style="color:#f92672">=</span> the_rwlock<span style="color:#f92672">-&gt;</span>Owner;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( owner <span style="color:#f92672">==</span> NULL ) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* No owner, we can acquire write lock */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_CORE_RWLock_Grant_writing_lock</span>( the_rwlock, executing, queue_context );
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/* Lock is held by someone, we must block */</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_CORE_RWLock_Enqueue_for_writing</span>( the_rwlock, executing, queue_context );
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="writer-lock-acquisition-states">Writer Lock Acquisition States<a hidden class="anchor" aria-hidden="true" href="#writer-lock-acquisition-states">#</a></h3>
<p>The writer lock can only be acquired in one scenario:</p>
<ol>
<li><strong>No Owner</strong>: The lock is completely free</li>
</ol>
<p>If there&rsquo;s any owner (reader or writer), the writer must block.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> Status_Control <span style="color:#a6e22e">_CORE_RWLock_Grant_writing_lock</span>(
</span></span><span style="display:flex;"><span>  CORE_RWLock_Control  <span style="color:#f92672">*</span>the_rwlock,
</span></span><span style="display:flex;"><span>  Thread_Control       <span style="color:#f92672">*</span>executing,
</span></span><span style="display:flex;"><span>  Thread_queue_Context <span style="color:#f92672">*</span>queue_context
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  the_rwlock<span style="color:#f92672">-&gt;</span>Owner <span style="color:#f92672">=</span> executing;
</span></span><span style="display:flex;"><span>  the_rwlock<span style="color:#f92672">-&gt;</span>number_of_readers <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Context_clear_priority_updates</span>( queue_context );
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">_Thread_queue_Release</span>( <span style="color:#f92672">&amp;</span>the_rwlock<span style="color:#f92672">-&gt;</span>Queue, queue_context );
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> STATUS_SUCCESSFUL;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function:</p>
<ul>
<li>Sets the owner to the writing thread</li>
<li>Clears the reader count</li>
<li>Releases the queue and returns success</li>
</ul>
<h2 id="understanding-rwlock-timeout-behavior">Understanding RWLock Timeout Behavior<a hidden class="anchor" aria-hidden="true" href="#understanding-rwlock-timeout-behavior">#</a></h2>
<p>Just like with condition variables, the clock type affects timeout behavior:</p>
<h3 id="clock_realtime-timeouts">CLOCK_REALTIME Timeouts<a hidden class="anchor" aria-hidden="true" href="#clock_realtime-timeouts">#</a></h3>
<ul>
<li><strong>Wall Clock Time</strong>: Timeout is based on absolute calendar time</li>
<li><strong>Affected by Time Changes</strong>: System clock adjustments can extend or shorten timeouts</li>
<li><strong>Use Case</strong>: When you need timeouts based on absolute calendar time</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> timespec timeout;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clock_gettime</span>(CLOCK_REALTIME, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span>timeout.tv_sec <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;  <span style="color:#75715e">// 5 seconds from now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Will timeout in 5 seconds of wall clock time
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_clockrdlock</span>(<span style="color:#f92672">&amp;</span>rwlock, CLOCK_REALTIME, <span style="color:#f92672">&amp;</span>timeout);
</span></span></code></pre></div><h3 id="clock_monotonic-timeouts">CLOCK_MONOTONIC Timeouts<a hidden class="anchor" aria-hidden="true" href="#clock_monotonic-timeouts">#</a></h3>
<ul>
<li><strong>System Uptime</strong>: Timeout is based on monotonic system time</li>
<li><strong>Immune to Time Changes</strong>: System clock adjustments don&rsquo;t affect it</li>
<li><strong>Use Case</strong>: When you need reliable relative timeouts</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> timespec timeout;
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clock_gettime</span>(CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span>timeout.tv_sec <span style="color:#f92672">+=</span> <span style="color:#ae81ff">5</span>;  <span style="color:#75715e">// 5 seconds from now
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Will timeout in exactly 5 seconds regardless of system clock changes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_clockrdlock</span>(<span style="color:#f92672">&amp;</span>rwlock, CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>timeout);
</span></span></code></pre></div><h2 id="thread-queue-management-and-priority">Thread Queue Management and Priority<a hidden class="anchor" aria-hidden="true" href="#thread-queue-management-and-priority">#</a></h2>
<p>RWLocks implement a sophisticated queuing system that handles both readers and writers:</p>
<h3 id="reader-priority">Reader Priority<a hidden class="anchor" aria-hidden="true" href="#reader-priority">#</a></h3>
<ul>
<li>Multiple readers can be granted the lock simultaneously</li>
<li>New readers can join existing readers without blocking</li>
<li>Readers block only when writers are active or waiting</li>
</ul>
<h3 id="writer-priority">Writer Priority<a hidden class="anchor" aria-hidden="true" href="#writer-priority">#</a></h3>
<ul>
<li>Writers get exclusive access</li>
<li>Writers block when any owner exists (reader or writer)</li>
<li>The queuing system ensures fairness between readers and writers</li>
</ul>
<h3 id="priority-inheritance">Priority Inheritance<a hidden class="anchor" aria-hidden="true" href="#priority-inheritance">#</a></h3>
<p>The RWLock implementation supports priority inheritance to prevent priority inversion:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define CORE_RWLOCK_TQ_OPERATIONS &amp;_Thread_queue_Operations_priority_inherit
</span></span></span></code></pre></div><p>This ensures that when a high-priority thread blocks on an RWLock, it can temporarily boost the priority of the lock holder.</p>
<h2 id="error-handling-and-return-values">Error Handling and Return Values<a hidden class="anchor" aria-hidden="true" href="#error-handling-and-return-values">#</a></h2>
<p>Both functions use the same error handling pattern:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_POSIX_Get_error</span>( status );
</span></span></code></pre></div><p>The <code>_POSIX_Get_error</code> function converts RTEMS internal status codes to POSIX error codes:</p>
<ul>
<li><code>STATUS_SUCCESSFUL</code> → <code>0</code></li>
<li><code>STATUS_TIMEOUT</code> → <code>ETIMEDOUT</code></li>
<li><code>STATUS_UNAVAILABLE</code> → <code>EBUSY</code></li>
<li><code>STATUS_OBJECT_WAS_DELETED</code> → <code>EINVAL</code></li>
<li><code>STATUS_DEADLOCK</code> → <code>EDEADLK</code></li>
</ul>
<h2 id="comparison-with-non-clock-variants">Comparison with Non-Clock Variants<a hidden class="anchor" aria-hidden="true" href="#comparison-with-non-clock-variants">#</a></h2>
<p>The clock-aware functions provide enhanced timeout control compared to their non-clock counterparts:</p>
<h3 id="traditional-timed-functions">Traditional Timed Functions<a hidden class="anchor" aria-hidden="true" href="#traditional-timed-functions">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Uses clock from rwlock attributes (usually CLOCK_REALTIME)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_timedrdlock</span>(<span style="color:#f92672">&amp;</span>rwlock, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_rwlock_timedwrlock</span>(<span style="color:#f92672">&amp;</span>rwlock, <span style="color:#f92672">&amp;</span>timeout);
</span></span></code></pre></div><h3 id="clock-aware-functions">Clock-Aware Functions<a hidden class="anchor" aria-hidden="true" href="#clock-aware-functions">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// Explicit clock selection
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">pthread_rwlock_clockrdlock</span>(<span style="color:#f92672">&amp;</span>rwlock, CLOCK_MONOTONIC, <span style="color:#f92672">&amp;</span>timeout);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">pthread_rwlock_clockwrlock</span>(<span style="color:#f92672">&amp;</span>rwlock, CLOCK_REALTIME, <span style="color:#f92672">&amp;</span>timeout);
</span></span></code></pre></div><h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>The pthread reader-writer lock clock functions in RTEMS demonstrate several key concepts:</p>
<ol>
<li><strong>Unified Timeout Handling</strong>: Both reader and writer functions use the same timeout setup mechanism</li>
<li><strong>Clock-Specific Callbacks</strong>: Different timeout behaviors are handled through appropriate timeout functions</li>
<li><strong>Reader-Writer Semantics</strong>: Multiple readers can coexist, but writers need exclusive access</li>
<li><strong>Priority Inheritance</strong>: The implementation prevents priority inversion through priority inheritance</li>
<li><strong>Robust Error Handling</strong>: Comprehensive error code mapping from internal status to POSIX errors</li>
</ol>
<h3 id="the-complete-flow-summary">The Complete Flow Summary<a hidden class="anchor" aria-hidden="true" href="#the-complete-flow-summary">#</a></h3>
<h4 id="for-reader-lock">For Reader Lock:<a hidden class="anchor" aria-hidden="true" href="#for-reader-lock">#</a></h4>
<ol>
<li><strong>API Entry</strong>: <code>pthread_rwlock_clockrdlock()</code> validates parameters and delegates to support function</li>
<li><strong>Timeout Setup</strong>: Appropriate timeout callback is selected based on clock type</li>
<li><strong>Lock Attempt</strong>: Check if lock can be acquired immediately (no owner or readers-only)</li>
<li><strong>Grant or Block</strong>: Either grant the lock immediately or enqueue the thread with timeout</li>
<li><strong>Wakeup Processing</strong>: When awakened, error codes are converted and returned</li>
</ol>
<h4 id="for-writer-lock">For Writer Lock:<a hidden class="anchor" aria-hidden="true" href="#for-writer-lock">#</a></h4>
<ol>
<li><strong>API Entry</strong>: <code>pthread_rwlock_clockwrlock()</code> validates parameters and delegates to support function</li>
<li><strong>Timeout Setup</strong>: Appropriate timeout callback is selected based on clock type</li>
<li><strong>Lock Attempt</strong>: Check if lock can be acquired immediately (no owner only)</li>
<li><strong>Grant or Block</strong>: Either grant exclusive access or enqueue the thread with timeout</li>
<li><strong>Wakeup Processing</strong>: When awakened, error codes are converted and returned</li>
</ol>
<p>This implementation showcases how RTEMS provides robust, real-time capable synchronization primitives while maintaining POSIX compliance and offering advanced features like configurable clock sources for timeout operations.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://mez3n.github.io/mez3n.blog/tags/pthread/">Pthread</a></li>
      <li><a href="https://mez3n.github.io/mez3n.blog/tags/rtems/">RTEMS</a></li>
      <li><a href="https://mez3n.github.io/mez3n.blog/tags/synchronization/">Synchronization</a></li>
      <li><a href="https://mez3n.github.io/mez3n.blog/tags/rwlock/">Rwlock</a></li>
      <li><a href="https://mez3n.github.io/mez3n.blog/tags/internals/">Internals</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://mez3n.github.io/mez3n.blog/">Mez3n&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
